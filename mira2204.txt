===========================================
=  Mira2204 Instruction Set Architecture  =
===========================================

REGISTERS
---------

nine  32-bit general-purpose registers (r0-r9)
one   16-bit status register (sr / r14)
four  16-bit arithmetic condition registers (cc0-cc3 / r10,r11)
one   32-bit call stack pointer register (isp / r13)
one   32-bit data stack pointer register (dsp / r12)
one   32-bit instruction pointer register (pc / r15)
one   32-bit context call stack pointer register (ssp)
one   32-bit context instruction pointer register (spc)


The layout and encoding number is like so:

   31                        16 15           9 8           0
  +----------------------------+----------------------------+
  |                            |              |             |
  |                            |              |             | r0 - r9   (0 - 9)
  |                            |              |             |
  +----------------------------+----------------------------+
  |             cc1            |            cc0             | cc1/0 / r10  (10)
  +----------------------------+----------------------------+
  |             cc3            |            cc2             | cc3/2 / r11  (11)
  +----------------------------+----------------------------+
  |                                dsp                      | dsp / r12    (12)
  +---------------------------------------------------------+
  |                                isp                      | isp / r13    (13)
  +----------------------------+----------------------------+
         reserved / zero       |             sr             | sr / r14     (14)
  +----------------------------+----------------------------+
  |                                pc                       | pc / r15     (15)
  +---------------------------------------------------------+
   31                        16 15                         0
  +---------------------------------------------------------+
  |                               ssp                       | ssp
  +---------------------------------------------------------+
  |                               spc                       | spc
  +---------------------------------------------------------+


STANDARD INSTRUCTION FORMAT
---------------------------

- has support for conditional instruction
- instructions are four bytes long
- each standard instruction has MSB 0 to
  distinguish them from the compact format.

LONG FORMAT IN GENERAL
c - conditional code
o - operator
r - conditional register 
V - reserved (should be set to 0)
x - operands (registers, immediates, etc.)

<- MSB                       LSB ->
0ooooooo VVrrcccc xxxxxxxx xxxxxxxx

Three-Operand Format (64)
01oooooo 00rrcccc zzzzzzzz yyyyxxxx (Note 2)

Two-Operand Format (32)
001ooooo 00rrcccc zzzzzzzz zzzzxxxx (Note 2)

One-Operand Format (16)
0001oooo 00rrcccc zzzzzzzz zzzzzzzz (Note 2)

Zero-Operand Format (8)
00001ooo 00rrcccc 00000000 00000000 (Note 3)

1 - registers only
2 - registers or immediate
3 - no operands


COMPACT INSTRUCTION FORMAT
--------------------------

- Instructions are two bytes long.
- Must be a multiple of two in a row, you can't have one just there on its own.
- Each two-byte instruction starts with 1.
- Execution is unconditional.
- Both instructions are executed even if i.e. pc is modified by the first.
- Each instruction in the pair is executed in sequence.
- When executed, the pc points to the next 4 byte instruction following the
  compact instructions.

FORMAT IN GENERAL
o - operation bits
w - primary operand (registers)
q - secondary operand (registers, immediate)

  Instruction 2     Instruction 1
<- MSB                       LSB ->
1ooooooo qqqqwwww 1ooooooo qqqqwwww

The operation bits select an instruction from the full instruction set,
with modified semantics for the operands.

 op bits    full set mapping
1100oooo - 0100oooo instruction with x = w, y = w, z = q, n = q
1101oooo - 0101oooo instruction with x = w, y = w, z = q, n = q

1110oooo - 0110oooo instruction with x = w, y = q, z = r8, n = 0
1111oooo - 0111oooo instruction with x = w, y = q, z = r8, n = 0

1010oooo - 0010oooo instruction with x = w, y = q, n = q
1011oooo - 0011oooo instruction with x = w, y = q, n = q

1001oooo - 0001oooo instruction with x = w, n = q:w
1000oooo - reserved operation.


CONDITION AND STATUS REGISTERS
------------------------------

Both sr and all cc* registers have the following layout:

 15             8 7             0
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |0|0|0|0|T|S|P|I|N|V|0|0|0|0|C|Z|
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Z (bit 0)  - Zero (set when last result was zero)
C (bit 1)  - Carry (set when last result carried)
V (bit 6)  - Overflow (set when last signed result overflowed)
N (bit 7)  - Negative (set when last result is negative)
I (bit 8)  - Interrupt, when set: prevents pending interrupts from processing,
             set when an interrupt occurs.
P (bit 9)  - Protect Enable, when set: certain operations generate traps,
             also prevents changing bits 8-31 in sr.
S (bit 10) - SR Trap, when both this bit and P (bit 9) are set: any writes to
             the sr register that would change bits 8-31 cause a CPU trap.
T (bit 11) - Trap, when this bit is set and P (bit 9) is clear,
             any traps generated will halt the processor.

CONDITIONAL INSTRUCTIONS
------------------------

If the condition code is zero then the instruction is executed
unconditionally, the condition register bits "rr" must be zero.
Otherwise the condition code bits specify a condition that must
be true to execute the instruction.

If false, then cpu aborts instruction decoding, advances the pc
to the next instruction, and goes back to the fetch stage.

There are four conditional registers, selected
with the conditional register selector bits "rr".
00   cc0
01   cc1
10   cc2
11   cc3

There are 4 condition code bits in each standard instruction,
they index the possible conditions to check:
0000   Always true
0001   overflow
0010   carry / unsigned greater than or equal
0011   unsigned greater than
0100   zero / equal to
0101   negative / signed less than
0110   signed greater than
0111   (reserved)
1000   Always false / never execute
1001   no overflow
1010   no carry / unsigned less than
1011   unsigned less than or equal
1100   not equal to
1101   positive / signed greater than or equal
1110   signed less than or equal
1111   (reserved)

STANDARD INSTRUCTION LISTING AND ENCODING
-----------------------------------------

INSTRUCTION FORMAT LEGEND
n   immediate
c   condition code
r   condition register
x   operand x
y   operand y
z   operand z

THREE-OPERAND FORMAT (64) - instr x,y,z or instr x,y,$n
01000000 00rrcccc 0000zzzz yyyyxxxx   add    x = y + z
01000001 00rrcccc 0000zzzz yyyyxxxx   sub    x = y - z
01000010 00rrcccc 0000zzzz yyyyxxxx   umul   r10:x = y * z (64 bit)
01000011 00rrcccc 0000zzzz yyyyxxxx   smul   r10:x = y * z (64 bit, signed)
01000100 00rrcccc 0000zzzz yyyyxxxx   udiv   x = y / z; r10 = y % z
01000101 00rrcccc 0000zzzz yyyyxxxx   sdiv   x = y / z; r10 = y % z (signed)
01000110 00rrcccc 0000zzzz yyyyxxxx   rotl   x = (y << z) | (y >> (32-z))
01000111 00rrcccc 0000zzzz yyyyxxxx   rotr   x = (y >> z) | (y << (32-z))

01001000 00rrcccc 0000zzzz yyyyxxxx   and    x = y & z
01001001 00rrcccc 0000zzzz yyyyxxxx   or     x = y | z
01001010 00rrcccc 0000zzzz yyyyxxxx   xor    x = y ^ z
01001011 00rrcccc 0000zzzz yyyyxxxx   sar    x = y >>> n
01001100 00rrcccc nnnnnnnn yyyyxxxx   rotl   x = (y << n) | (y >> (32-n))
01001101 00rrcccc nnnnnnnn yyyyxxxx   rotr   x = (y >> n) | (y << (32-n))
01001110 00rrcccc 0000zzzz yyyyxxxx   shl    x = y << n
                                      sal    (alias shl)
01001111 00rrcccc 0000zzzz yyyyxxxx   shr    x = y >> n

0101oooo 00rrcccc nnnnnnnn yyyyxxxx   (reserved)

01100000 00rrcccc nnnnnnnn yyyyxxxx   stb    *(x+n) = LOWER_8(y)
01100001 00rrcccc nnnnnnnn yyyyxxxx   stbu   *(x+n) = LOWER_8(y); x += 1
01100010 00rrcccc 0000zzzz yyyyxxxx   stbi   *(x+z) = LOWER_8(y)
01100011 00rrcccc 0000zzzz yyyyxxxx   stbui  *(x+z) = LOWER_8(y); x += 1
01100100 00rrcccc nnnnnnnn yyyyxxxx   sth    *(x+n) = LOWER_16(y)
01100101 00rrcccc nnnnnnnn yyyyxxxx   sthu   *(x+n) = LOWER_16(y); x += 2
01100110 00rrcccc 0000zzzz yyyyxxxx   sthi   *(x+z) = LOWER_16(y)
01100111 00rrcccc 0000zzzz yyyyxxxx   sthui  *(x+z) = LOWER_16(y); x += 2

01101000 00rrcccc nnnnnnnn yyyyxxxx   stw    *(x+n) = y
01101001 00rrcccc nnnnnnnn yyyyxxxx   stwu   *(x+n) = y; x += 4
01101010 00rrcccc 0000zzzz yyyyxxxx   stwi   *(x+z) = y
01101011 00rrcccc 0000zzzz yyyyxxxx   stwui  *(x+z) = y; x += 4

01101100 00rrcccc nnnnnnnn yyyyxxxx   lw     x = *(y+n)
01101101 00rrcccc nnnnnnnn yyyyxxxx   lwu    x = *(y+n); y += 4
01101110 00rrcccc 0000zzzz yyyyxxxx   lwi    x = *(y+z)
01101111 00rrcccc 0000zzzz yyyyxxxx   lwui   x = *(y+z); y += 4

01110000 00rrcccc nnnnnnnn yyyyxxxx   lzb    x = ZERO_EXTEND_8_TO_32(*(y+n))
01110001 00rrcccc nnnnnnnn yyyyxxxx   lzbu   x = ZERO_EXTEND_8_TO_32(*(y+n)); y += 1
01110010 00rrcccc 0000zzzz yyyyxxxx   lzbi   x = ZERO_EXTEND_8_TO_32(*(y+z))
01110011 00rrcccc 0000zzzz yyyyxxxx   lzbui  x = ZERO_EXTEND_8_TO_32(*(y+z)); y += 1
01110100 00rrcccc nnnnnnnn yyyyxxxx   lsb    x = SIGN_EXTEND_8_TO_32(*(y+n))
01110101 00rrcccc nnnnnnnn yyyyxxxx   lsbu   x = SIGN_EXTEND_8_TO_32(*(y+n)); y += 1
01110110 00rrcccc 0000zzzz yyyyxxxx   lsbi   x = SIGN_EXTEND_8_TO_32(*(y+z))
01110111 00rrcccc 0000zzzz yyyyxxxx   lsbui  x = SIGN_EXTEND_8_TO_32(*(y+z)); y += 1

01111000 00rrcccc nnnnnnnn yyyyxxxx   lzh    x = ZERO_EXTEND_16_TO_32(*(y+n))
01111001 00rrcccc nnnnnnnn yyyyxxxx   lzhu   x = ZERO_EXTEND_16_TO_32(*(y+n)); y += 2
01111010 00rrcccc 0000zzzz yyyyxxxx   lzhi   x = ZERO_EXTEND_16_TO_32(*(y+z))
01111011 00rrcccc 0000zzzz yyyyxxxx   lzhui  x = ZERO_EXTEND_16_TO_32(*(y+z)); y += 2
01111100 00rrcccc nnnnnnnn yyyyxxxx   lsh    x = SIGN_EXTEND_16_TO_32(*(y+n))
01111101 00rrcccc nnnnnnnn yyyyxxxx   lshu   x = SIGN_EXTEND_16_TO_32(*(y+n)); y += 2
01111110 00rrcccc 0000zzzz yyyyxxxx   lshi   x = SIGN_EXTEND_16_TO_32(*(y+z))
01111111 00rrcccc 0000zzzz yyyyxxxx   lshui  x = SIGN_EXTEND_16_TO_32(*(y+z)); y += 2

TWO-OPERAND FORMAT (32) - instr x,y or instr x,$n
00100000 00rrcccc 00000000 yyyyxxxx   mov    x = y
00100001 00rrcccc 00000000 yyyyxxxx   swp    x = y; y = x  (in parallel)
00100010 00rrcccc 00000000 yyyyxxxx   not    x = !y
00100011 00rrcccc 00000000 yyyyxxxx   cmp    (x - y)  (updates sr)
00100100 00rrcccc 00000000 yyyyxxxx   sxb    x = SIGN_EXTEND_8_TO_32(y)
00100101 00rrcccc 00000000 yyyyxxxx   sxw    x = SIGN_EXTEND_16_TO_32(y)
00100110 00rrcccc 00000000 yyyyxxxx   zxb    x = ZERO_EXTEND_8_TO_32(y)
00100111 00rrcccc 00000000 yyyyxxxx   zxw    x = ZERO_EXTEND_16_TO_32(y)
00101000 00rrcccc 00000000 yyyyxxxx   cpr0   cc0 =  FLAGS_OF( x - y )
00101001 00rrcccc 00000000 yyyyxxxx   cpr1   cc1 =  FLAGS_OF( x - y )
00101010 00rrcccc 00000000 yyyyxxxx   cpr2   cc2 =  FLAGS_OF( x - y )
00101011 00rrcccc 00000000 yyyyxxxx   cpr3   cc3 =  FLAGS_OF( x - y )
00101100 00rrcccc 00000000 yyyyxxxx   mvhh   HIGH16(x) = HIGH16(y)
00101101 00rrcccc 00000000 yyyyxxxx   mvhl   LOW16(x)  = HIGH16(y)
00101110 00rrcccc 00000000 yyyyxxxx   mvlh   HIGH16(x) = LOW16(y)
00101111 00rrcccc 00000000 yyyyxxxx   mvll   LOW16(x)  = LOW16(y)
00110000 00rrcccc nnnnnnnn nnnnxxxx   add    x = x + n
00110001 00rrcccc nnnnnnnn nnnnxxxx   sub    x = x - n
00110010 00rrcccc 00000000 yyyyxxxx   push   x -= 4; *(x) = y
00110011 00rrcccc 00000000 yyyyxxxx   pop    x = *(y); y += 4
00110100 00rrcccc 00000000 yyyyxxxx   mov    (reserved if x != 15 && x != 13)
00110100 00rrcccc 00000000 yyyy1101  "mov ssp, y"   ssp = y
00110100 00rrcccc 00000000 yyyy1111  "mov spc, y"   spc = y
00110101 00rrcccc 00000000 yyyyxxxx   mov    (reserved if y != 15 && y != 13)
00110101 00rrcccc 00000000 1101xxxx  "mov x, ssp"   x = ssp
00110101 00rrcccc 00000000 1111xxxx  "mov x, spc"   x = spc
00110110 00rrcccc 00000000 yyyyxxxx   (reserved)
00110111 00rrcccc 00000000 yyyyxxxx   (reserved)
00111ooo 00rrcccc 00000000 yyyyxxxx   (reserved)

ONE-OPERAND FORMAT (16) - instr x or instr $n
00010000 00rrcccc nnnnnnnn nnnnnnnn   ba     pc = n << 2
00010001 00rrcccc nnnnnnnn nnnnnnnn   br     pc += n << 2
00010010 00rrcccc nnnnnnnn nnnnnnnn   (reserved)
00010011 00rrcccc nnnnnnnn nnnnnnnn   (reserved)
00010100 00rrcccc nnnnnnnn nnnnnnnn   call   isp -= 4; *(isp) = pc;
                                             isp -= 4; *(isp) = dsp; pc = n << 2
00010101 00rrcccc nnnnnnnn nnnnnnnn   callr  isp -= 4; *(isp) = pc;
                                             isp -= 4; *(isp) = dsp; pc += n << 2
00010110 00rrcccc nnnnnnnn nnnnnnnn   fcall  r8 = dsp; r9 = pc; pc = n << 2
00010111 00rrcccc nnnnnnnn nnnnnnnn   fcallr r8 = dsp; r9 = pc; pc += n << 2

00011000 00rrcccc nnnnnnnn nnnnnnnn   int    (software interrupt n)
00011001 00rrcccc nnnnnnnn nnnnnnnn   (reserved)
00011010 00rrcccc nnnnnnnn nnnnnnnn   lil    cc0 = n
00011011 00rrcccc nnnnnnnn nnnnnnnn   lih    cc1 = n
00011100 00rrcccc 00000000 0000xxxx   (reserved)
00011101 00rrcccc 00000000 0000xxxx   (reserved)
00011110 00rrcccc 00000000 0000xxxx   (reserved)
00011111 00rrcccc 00000000 0000xxxx   (reserved)

ZERO-OPERAND FORMAT (8) - instr
00000ooo 00000000 00000000 00000000   (reserved)
00001000 00rrcccc 00000000 00000000   ret    dsp = *(isp); isp += 4;
                                             pc = *(isp); isp += 4
00001001 00rrcccc 00000000 00000000   fret   dsp = r8; pc = r9
00001010 00rrcccc 00000000 00000000   sleep  (sleep until interrupt)
00001011 00rrcccc 00000000 00000000   rfi    (return from interrupt)
00001ooo 00rrcccc 00000000 00000000   (reserved)
00001111 00rrcccc 00000000 00000000   brk    pc = pc


INTERRUPTS
----------

(to be expanded later)

