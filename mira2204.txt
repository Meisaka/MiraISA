===========================================
=  Mira2204 Instruction Set Architecture  =
===========================================

REGISTERS
---------

nine  32-bit general-purpose registers (r0-r9)
one   16-bit status register (sr / r14)
four  16-bit arithmetic condition registers (cc0-cc3 / r10,r11)
one   32-bit call stack pointer register (isp / r13)
one   32-bit data stack pointer register (dsp / r12)
one   32-bit instruction pointer register (pc / r15)
one   32-bit context call stack pointer register (ssp)
one   32-bit context instruction pointer register (spc)


The layout and encoding number is like so:

   31                        16 15           9 8           0
  +----------------------------+----------------------------+
  |                            |              |             |
  |                            |              |             | r0 - r9   (0 - 9)
  |                            |              |             |
  +----------------------------+----------------------------+
  |             cc1            |            cc0             | cc1/0 / r10  (10)
  +----------------------------+----------------------------+
  |             cc3            |            cc2             | cc3/2 / r11  (11)
  +----------------------------+----------------------------+
  |                                dsp                      | dsp / r12    (12)
  +---------------------------------------------------------+
  |                                isp                      | isp / r13    (13)
  +----------------------------+----------------------------+
         reserved / zero       |             sr             | sr / r14     (14)
  +----------------------------+----------------------------+
  |                                pc                       | pc / r15     (15)
  +---------------------------------------------------------+
   31                        16 15                         0
  +---------------------------------------------------------+
  |                               ssp                       | ssp
  +---------------------------------------------------------+
  |                               spc                       | spc
  +---------------------------------------------------------+


STANDARD INSTRUCTION FORMAT
---------------------------

- has support for conditional instruction
- instructions are four bytes long
- each standard instruction has MSB 0 to
  distinguish them from the compact format.

LONG FORMAT IN GENERAL
c - conditional code
o - operator
r - conditional register 
V - reserved (should be set to 0)
x - operands (registers, immediates, etc.)

<- MSB                       LSB ->
0ooooooo VVrrcccc xxxxxxxx xxxxxxxx

Three-Operand Format (64)
01oooooo 00rrcccc zzzzzzzz yyyyxxxx (Note 2)

Two-Operand Format (32)
001ooooo 00rrcccc zzzzzzzz zzzzxxxx (Note 2)

One-Operand Format (16)
0001oooo 00rrcccc zzzzzzzz zzzzzzzz (Note 2)

Zero-Operand Format (8)
00001ooo 00rrcccc 00000000 00000000 (Note 3)

1 - registers only
2 - registers or immediate
3 - no operands


COMPACT INSTRUCTION FORMAT
--------------------------

- Instructions are two bytes long.
- Must be a multiple of two in a row, you can't have one just there on its own.
- Each two-byte instruction starts with 1.
- Execution is unconditional.
- Both instructions are executed even if i.e. pc is modified by the first.
- Each instruction in the pair is executed in sequence.
- When executed, the pc points to the next 4 byte instruction following the
  compact instructions.

FORMAT IN GENERAL
o - operation bits
w - primary operand (registers)
q - secondary operand (registers, immediate)

  Instruction 2     Instruction 1
<- MSB                       LSB ->
1ooooooo qqqqwwww 1ooooooo qqqqwwww

The operation bits select an instruction from the full instruction set,
with modified semantics for the operands.

 op bits    full set mapping
1100oooo - 0100oooo instruction with x = w, y = w, z = q, n = q
1101oooo - 0101oooo instruction with x = w, y = w, z = q, n = q

1110oooo - 0110oooo instruction with x = w, y = q, z = r8, n = 0
1111oooo - 0111oooo instruction with x = w, y = q, z = r8, n = 0

1010oooo - 0010oooo instruction with x = w, y = q, n = q
1011oooo - 0011oooo instruction with x = w, y = q, n = q

1001oooo - 0001oooo instruction with x = w, n = q:w
1000oooo - reserved operation.


CONDITION AND STATUS REGISTERS
------------------------------

Both sr and all cc* registers have the following layout:

 15             8 7             0
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |0|0|0|F|T|S|P|I|N|V|0|0|0|0|C|Z|
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Z (bit 0)  - Zero (set when last result was zero)
C (bit 1)  - Carry (set when last result carried)
V (bit 6)  - Overflow (set when last signed result overflowed)
N (bit 7)  - Negative (set when last result is negative)
I (bit 8)  - Interrupt, when set: prevents pending interrupts from processing,
             set when an interrupt occurs.
P (bit 9)  - Protect Enable, when set: certain operations generate traps,
             also prevents changing bits 8-31 in sr. Any changes to this bit
             will cause the CPU to context switch (see CONTEXT SWITCHING.)
S (bit 10) - SR Trap, when both this bit and P (bit 9) are set: any writes to
             the sr register that would change bits 8-31 cause a CPU trap.
T (bit 11) - Trap, when this bit is set and P (bit 9) is clear,
             any traps generated will halt the processor.
F (bit 12) - Full Halt, when set: the CPU will stop executing instructions,
             interrupts will still be processed in this state unless masked.


CONDITIONAL INSTRUCTIONS
------------------------

If the condition code is zero then the instruction is executed
unconditionally, the condition register bits "rr" must be zero.
Otherwise the condition code bits specify a condition that must
be true to execute the instruction.

If false, then cpu aborts instruction decoding, advances the pc
to the next instruction, and goes back to the fetch stage.

There are four conditional registers, selected
with the conditional register selector bits "rr".
00   cc0
01   cc1
10   cc2
11   cc3

There are 4 condition code bits in each standard instruction,
they index the possible conditions to check:
0000   Always true
0001   overflow
0010   carry / unsigned greater than or equal
0011   unsigned greater than
0100   zero / equal to
0101   negative / signed less than
0110   signed greater than
0111   (reserved)
1000   Always false / never execute
1001   no overflow
1010   no carry / unsigned less than
1011   unsigned less than or equal
1100   not equal to
1101   positive / signed greater than or equal
1110   signed less than or equal
1111   (reserved)


STANDARD INSTRUCTION LISTING AND ENCODING
-----------------------------------------

INSTRUCTION FORMAT LEGEND
o   opcode bits
n   immediate
c   condition code
r   condition register
x   operand x
y   operand y
z   operand z

THREE-OPERAND FORMAT (64) - instr x,y,z or instr x,y,$n
01000000 00rrcccc 0000zzzz yyyyxxxx   add    x = y + z
01000001 00rrcccc 0000zzzz yyyyxxxx   sub    x = y - z
01000010 00rrcccc 0000zzzz yyyyxxxx   umul   r10:x = y * z (64 bit)
01000011 00rrcccc 0000zzzz yyyyxxxx   smul   r10:x = y * z (64 bit, signed)
01000100 00rrcccc 0000zzzz yyyyxxxx   udiv   x = y / z; r10 = y % z
01000101 00rrcccc 0000zzzz yyyyxxxx   sdiv   x = y / z; r10 = y % z (signed)
01000110 00rrcccc 0000zzzz yyyyxxxx   rotl   x = (y << z) | (y >> (32-z))
01000111 00rrcccc 0000zzzz yyyyxxxx   rotr   x = (y >> z) | (y << (32-z))

01001000 00rrcccc 0000zzzz yyyyxxxx   and    x = y & z
01001001 00rrcccc 0000zzzz yyyyxxxx   or     x = y | z
01001010 00rrcccc 0000zzzz yyyyxxxx   xor    x = y ^ z
01001011 00rrcccc 0000zzzz yyyyxxxx   sar    x = y >>> n
01001100 00rrcccc nnnnnnnn yyyyxxxx   rotl   x = (y << n) | (y >> (32-n))
01001101 00rrcccc nnnnnnnn yyyyxxxx   rotr   x = (y >> n) | (y << (32-n))
01001110 00rrcccc 0000zzzz yyyyxxxx   shl    x = y << n
                                      sal    (alias shl)
01001111 00rrcccc 0000zzzz yyyyxxxx   shr    x = y >> n

0101oooo 00rrcccc nnnnnnnn yyyyxxxx   (reserved)

01100000 00rrcccc nnnnnnnn yyyyxxxx   stb    *(x+n) = LOWER_8(y)
01100001 00rrcccc nnnnnnnn yyyyxxxx   stbu   *(x+n) = LOWER_8(y); x += 1
01100010 00rrcccc 0000zzzz yyyyxxxx   stbi   *(x+z) = LOWER_8(y)
01100011 00rrcccc 0000zzzz yyyyxxxx   stbui  *(x+z) = LOWER_8(y); x += 1
01100100 00rrcccc nnnnnnnn yyyyxxxx   sth    *(x+n) = LOWER_16(y)
01100101 00rrcccc nnnnnnnn yyyyxxxx   sthu   *(x+n) = LOWER_16(y); x += 2
01100110 00rrcccc 0000zzzz yyyyxxxx   sthi   *(x+z) = LOWER_16(y)
01100111 00rrcccc 0000zzzz yyyyxxxx   sthui  *(x+z) = LOWER_16(y); x += 2

01101000 00rrcccc nnnnnnnn yyyyxxxx   stw    *(x+n) = y
01101001 00rrcccc nnnnnnnn yyyyxxxx   stwu   *(x+n) = y; x += 4
01101010 00rrcccc 0000zzzz yyyyxxxx   stwi   *(x+z) = y
01101011 00rrcccc 0000zzzz yyyyxxxx   stwui  *(x+z) = y; x += 4

01101100 00rrcccc nnnnnnnn yyyyxxxx   lw     x = *(y+n)
01101101 00rrcccc nnnnnnnn yyyyxxxx   lwu    x = *(y+n); y += 4
01101110 00rrcccc 0000zzzz yyyyxxxx   lwi    x = *(y+z)
01101111 00rrcccc 0000zzzz yyyyxxxx   lwui   x = *(y+z); y += 4

01110000 00rrcccc nnnnnnnn yyyyxxxx   lzb    x = ZERO_EXTEND_8_TO_32(*(y+n))
01110001 00rrcccc nnnnnnnn yyyyxxxx   lzbu   x = ZERO_EXTEND_8_TO_32(*(y+n)); y += 1
01110010 00rrcccc 0000zzzz yyyyxxxx   lzbi   x = ZERO_EXTEND_8_TO_32(*(y+z))
01110011 00rrcccc 0000zzzz yyyyxxxx   lzbui  x = ZERO_EXTEND_8_TO_32(*(y+z)); y += 1
01110100 00rrcccc nnnnnnnn yyyyxxxx   lsb    x = SIGN_EXTEND_8_TO_32(*(y+n))
01110101 00rrcccc nnnnnnnn yyyyxxxx   lsbu   x = SIGN_EXTEND_8_TO_32(*(y+n)); y += 1
01110110 00rrcccc 0000zzzz yyyyxxxx   lsbi   x = SIGN_EXTEND_8_TO_32(*(y+z))
01110111 00rrcccc 0000zzzz yyyyxxxx   lsbui  x = SIGN_EXTEND_8_TO_32(*(y+z)); y += 1

01111000 00rrcccc nnnnnnnn yyyyxxxx   lzh    x = ZERO_EXTEND_16_TO_32(*(y+n))
01111001 00rrcccc nnnnnnnn yyyyxxxx   lzhu   x = ZERO_EXTEND_16_TO_32(*(y+n)); y += 2
01111010 00rrcccc 0000zzzz yyyyxxxx   lzhi   x = ZERO_EXTEND_16_TO_32(*(y+z))
01111011 00rrcccc 0000zzzz yyyyxxxx   lzhui  x = ZERO_EXTEND_16_TO_32(*(y+z)); y += 2
01111100 00rrcccc nnnnnnnn yyyyxxxx   lsh    x = SIGN_EXTEND_16_TO_32(*(y+n))
01111101 00rrcccc nnnnnnnn yyyyxxxx   lshu   x = SIGN_EXTEND_16_TO_32(*(y+n)); y += 2
01111110 00rrcccc 0000zzzz yyyyxxxx   lshi   x = SIGN_EXTEND_16_TO_32(*(y+z))
01111111 00rrcccc 0000zzzz yyyyxxxx   lshui  x = SIGN_EXTEND_16_TO_32(*(y+z)); y += 2

TWO-OPERAND FORMAT (32) - instr x,y or instr x,$n
00100000 00rrcccc 00000000 yyyyxxxx   mov    x = y
00100001 00rrcccc 00000000 yyyyxxxx   swp    x = y; y = x  (in parallel)
00100010 00rrcccc 00000000 yyyyxxxx   not    x = !y
00100011 00rrcccc 00000000 yyyyxxxx   cmp    (x - y)  (updates sr)
00100100 00rrcccc 00000000 yyyyxxxx   sxb    x = SIGN_EXTEND_8_TO_32(y)
00100101 00rrcccc 00000000 yyyyxxxx   sxw    x = SIGN_EXTEND_16_TO_32(y)
00100110 00rrcccc 00000000 yyyyxxxx   zxb    x = ZERO_EXTEND_8_TO_32(y)
00100111 00rrcccc 00000000 yyyyxxxx   zxw    x = ZERO_EXTEND_16_TO_32(y)
00101000 00rrcccc 00000000 yyyyxxxx   cpr0   cc0 =  FLAGS_OF( x - y )
00101001 00rrcccc 00000000 yyyyxxxx   cpr1   cc1 =  FLAGS_OF( x - y )
00101010 00rrcccc 00000000 yyyyxxxx   cpr2   cc2 =  FLAGS_OF( x - y )
00101011 00rrcccc 00000000 yyyyxxxx   cpr3   cc3 =  FLAGS_OF( x - y )
00101100 00rrcccc 00000000 yyyyxxxx   mvhh   HIGH16(x) = HIGH16(y)
00101101 00rrcccc 00000000 yyyyxxxx   mvhl   LOW16(x)  = HIGH16(y)
00101110 00rrcccc 00000000 yyyyxxxx   mvlh   HIGH16(x) = LOW16(y)
00101111 00rrcccc 00000000 yyyyxxxx   mvll   LOW16(x)  = LOW16(y)
00110000 00rrcccc nnnnnnnn nnnnxxxx   add    x = x + n
00110001 00rrcccc nnnnnnnn nnnnxxxx   sub    x = x - n
00110010 00rrcccc 00000000 yyyyxxxx   push   x -= 4; *(x) = y
00110011 00rrcccc 00000000 yyyyxxxx   pop    x = *(y); y += 4
00110100 00rrcccc 00000000 yyyyxxxx   mov    (reserved if x != 15 && x != 13)
00110100 00rrcccc 00000000 yyyy1101  "mov ssp, y"   ssp = y
00110100 00rrcccc 00000000 yyyy1111  "mov spc, y"   spc = y
00110101 00rrcccc 00000000 yyyyxxxx   mov    (reserved if y != 15 && y != 13)
00110101 00rrcccc 00000000 1101xxxx  "mov x, ssp"   x = ssp
00110101 00rrcccc 00000000 1111xxxx  "mov x, spc"   x = spc
00110110 00rrcccc 00000000 yyyyxxxx   (reserved)
00110111 00rrcccc 00000000 yyyyxxxx   (reserved)
00111ooo 00rrcccc 00000000 yyyyxxxx   (reserved)

ONE-OPERAND FORMAT (16) - instr x or instr $n
00010000 00rrcccc nnnnnnnn nnnnnnnn   ba     pc = n << 2
00010001 00rrcccc nnnnnnnn nnnnnnnn   br     pc += n << 2
00010010 00rrcccc nnnnnnnn nnnnnnnn   (reserved)
00010011 00rrcccc nnnnnnnn nnnnnnnn   (reserved)
00010100 00rrcccc nnnnnnnn nnnnnnnn   call   isp -= 4; *(isp) = pc;
                                             isp -= 4; *(isp) = dsp; pc = n << 2
00010101 00rrcccc nnnnnnnn nnnnnnnn   callr  isp -= 4; *(isp) = pc;
                                             isp -= 4; *(isp) = dsp; pc += n << 2
00010110 00rrcccc nnnnnnnn nnnnnnnn   fcall  r8 = dsp; r9 = pc; pc = n << 2
00010111 00rrcccc nnnnnnnn nnnnnnnn   fcallr r8 = dsp; r9 = pc; pc += n << 2

00011000 00rrcccc nnnnnnnn nnnnnnnn   int    (software interrupt n)
00011001 00rrcccc nnnnnnnn nnnnnnnn   (reserved)
00011010 00rrcccc nnnnnnnn nnnnnnnn   lil    cc0 = n
00011011 00rrcccc nnnnnnnn nnnnnnnn   lih    cc1 = n
00011100 00rrcccc 00000000 0000xxxx   (reserved)
00011101 00rrcccc 00000000 0000xxxx   (reserved)
00011110 00rrcccc 00000000 0000xxxx   (reserved)
00011111 00rrcccc 00000000 0000xxxx   (reserved)

ZERO-OPERAND FORMAT (8) - instr
00000ooo 00000000 00000000 00000000   (reserved)
00001000 00rrcccc 00000000 00000000   ret    dsp = *(isp); isp += 4;
                                             pc = *(isp); isp += 4
00001001 00rrcccc 00000000 00000000   fret   dsp = r8; pc = r9
00001010 00rrcccc 00000000 00000000   sleep  sr = sr | 0x1000 (halt until interrupt)
00001011 00rrcccc 00000000 00000000   rfi    (return from interrupt)
00001ooo 00rrcccc 00000000 00000000   (reserved)
00001111 00rrcccc 00000000 00000000   brk    pc = pc


CONTEXT SWITCHING
-----------------

The CPU can be running one of two modes at any time: system mode or protected
mode (also called user mode.)
The current mode is indicated by the state of the P bit in sr.
If P is clear, the CPU is running in system mode.
If P is set, the CPU is running in protected mode.
If this bit changed by software (set, since software can not clear it), or
a context switch is required by CPU hardware, the CPU performs these actions:
- isp and ssp are exchanged
- pc and spc are exchanged
- if the CPU is switching to system mode, the P bit in sr is cleared.
- if the CPU is switching to protected mode, the P bit in sr is set.


INTERRUPTS AND TRAPS
--------------------

- The CPU indexes traps and interrupts using a 256 entry table starting
  at address zero. Each entry is 32 bits, and contains the address of
  a routine to execute for a given trap/interrupt.
- The software interupt operation (int n), the instuction will use the lower
  8 bits of n as the index into the interrupt table, and generate an
  interrupt at that index. The upper 8 bits are ignored by hardware, and
  may be used by software for further decoding/indexing. If the I bit in sr is
  set, this will generate a special trap instead (see below.)
- Hardware interrupts generate an 8 bit index for the interrupt table in a
  platform specific way. Hardware interrupts are inhibited if the I bit in sr
  is set, and will be processed when I is cleared.

- When an interrupt is processed, the CPU will context switch to system mode
  if needed, clear the F bit in sr, push pc then 32-bit sr onto isp, 
  set the I flag in sr, and finally load pc with the address from the interrupt
  table using the interrupt index.
- A Trap is an exceptional condition raised by certain CPU operations.
  When a trap is raised, the CPU will context switch to system mode if needed,
  push pc then 32-bit sr onto isp, set the Trap flag (T) in sr, and then load
  pc with with the address from the interrupt table using the trap index.
- If the T bit in sr is set, and a trap is raised, the CPU will set the F bit
  in sr, abort all current operations and halt. If the I bit is also set,
  then a NMI or Reset is the only way resume the CPU from this state.

- the "rfi" or return from interrupt instruction, will pop 32 sr, followed by
  pc, from isp. If this results in a change to the P flag in sr, the CPU will
  then perform the context switch after pc is popped.
- The CPU has a non-maskable interrupt connection, if asserted, the CPU will
  process an interrupt with index 1, regardless of the operational state of
  the CPU, including when either the F or I bits in sr are set.

Indexes of special CPU Trap / Interrupt entries:
  0  Reset - Loaded at reset.
  0  NMI   - Non maskable interrupt.
  1  Break Trap
         - raised when a brk is executed in protected mode.
  2  Invalid Opcode Trap
         - raised when reserved opcodes are executed.
  3  Protection Trap
         - raised when a system mode instruction is executed while
           in protected mode.
  4  Math Trap
         - raised by udiv or sdiv when the z operand evaluates to zero.
  5  Software int Trap
         - raised when an int instruction is processed while
           the I bit in sr is currently set.
  6  SR Write Trap
         - raised when protected mode attepted to change bits 8-31
           of sr and the S bit in sr is set.
  7  pc alignment Trap
         - raised when any instruction sets bit 0 or 1 of pc.
  8  alignment Trap
         - raised when any 32 bit read/write accesses an address
           with bits 0 or 1 set. or a 16 bit read/write accesses
           an address with bit 0 set.
  9  access Trap
         - raised by external hardware when a memory access fails.
10-15 - reserved for further CPU Traps


CPU RESET STATE
---------------

On Reset, the CPU will:
- Clear all registers to zero.
- Set the I and T bits in sr, inhibiting interrupts and forcing halt on any
  trap raised.
- Load pc with the reset vector (address 0)
- Begin instruction execution.

The reset signal is an inverted level input (active low), the CPU will
unconditionally halt on low input, and will begin the reset sequence on a
high going edge. This allows hardware the chance to reset and enter a valid
state before the CPU begins to access it.


SYSTEM MODE INSTRUCTIONS
------------------------

These instructions may only be executed while in system mode, execution from
protected mode results in raising a Protection Trap:

brk (raises a Break Trap instead)
mov (only with x0110100 or x0110101 encodings)
rfi
sleep

- The x0110100 and x0110101 encodings of "mov" have operands that are
  considered reserved instructions, executing this instruction with
  reserved operands raises a Protection Trap while in protected mode,
  and an Invalid Opcode Trap while in system mode.

- In protected mode, the condition bits are evaluated before executing
  the instruction, this means that if the condition evaluates false,
  the operation will not raise a trap in protected mode and the instruction
  will be skipped.


